<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2D5016">
    <title>Recording ‚Äî InstaBio</title>
    <link rel="manifest" href="/manifest.json">
    
    <style>
        :root {
            --color-primary: #2D5016;
            --color-primary-light: #3D6B1E;
            --color-background: #FFF8F0;
            --color-white: #FFFFFF;
            --color-text: #1A1A1A;
            --color-text-light: #4A4A4A;
            --color-blue: #2563EB;
            --color-green: #16A34A;
            --color-red: #DC2626;
            --font-body: 20px;
            --touch-min: 64px;
            --spacing: 24px;
            --radius: 16px;
        }
        
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: var(--font-body);
            line-height: 1.5;
            color: var(--color-text);
            background: var(--color-background);
            min-height: 100vh;
            overflow: hidden;
            transition: box-shadow 0.5s ease;
        }
        
        body.recording-glow {
            animation: green-breathe 4.5s ease-in-out infinite;
        }
        
        @keyframes green-breathe {
            0%, 100% { box-shadow: inset 0 0 30px 10px rgba(22, 163, 74, 0.15), 0 0 60px 20px rgba(22, 163, 74, 0.1); }
            50% { box-shadow: inset 0 0 80px 30px rgba(22, 163, 74, 0.35), 0 0 120px 50px rgba(22, 163, 74, 0.25); }
        }
        
        /* ===== Interview Mode Toggle ===== */
        .mode-toggle {
            display: flex;
            background: var(--color-white);
            border-radius: var(--radius);
            margin-bottom: 12px;
            overflow: hidden;
            border: 2px solid var(--color-primary);
        }
        .mode-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            background: transparent;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            color: var(--color-primary);
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: var(--color-primary);
            color: var(--color-white);
        }
        .guided-coming-soon {
            display: none;
            background: var(--color-white);
            border-radius: var(--radius);
            padding: 24px;
            text-align: center;
            margin-bottom: 16px;
            border: 2px dashed var(--color-primary);
        }
        .guided-coming-soon h3 { color: var(--color-primary); margin-bottom: 8px; }
        .guided-coming-soon p { color: var(--color-text-light); font-size: 17px; }
        
        /* ===== Main Container ===== */
        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: var(--spacing);
            padding-bottom: 180px;
        }
        
        /* ===== Header ===== */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .logo {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-primary);
            text-decoration: none;
        }
        .nav-links { display: flex; gap: 8px; }
        .nav-link {
            font-size: 18px;
            color: var(--color-primary);
            text-decoration: underline;
            padding: 12px;
            min-height: 48px;
            display: flex;
            align-items: center;
        }
        
        /* ===== Wi-Fi Indicator ===== */
        .wifi-indicator {
            text-align: center;
            font-size: 15px;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            background: rgba(45, 80, 22, 0.08);
            color: var(--color-text-light);
        }
        
        /* ===== Status Bar ===== */
        .status-bar {
            text-align: center;
            padding: 16px;
            background: var(--color-white);
            border-radius: var(--radius);
            margin-bottom: 12px;
        }
        .timer {
            font-size: 56px;
            font-weight: 700;
            color: var(--color-primary);
            font-variant-numeric: tabular-nums;
            line-height: 1.1;
        }
        .status-text {
            font-size: 20px;
            color: var(--color-text-light);
            margin-top: 6px;
        }
        .status-text.recording { color: var(--color-green); font-weight: 600; }
        .status-text.paused { color: var(--color-red); }
        
        .saving-status {
            font-size: 18px;
            color: var(--color-primary);
            margin-top: 8px;
            min-height: 24px;
        }
        
        /* ===== Transcript Area ===== */
        .transcript-area {
            flex: 1;
            background: var(--color-white);
            border-radius: var(--radius);
            padding: var(--spacing);
            overflow-y: auto;
            margin-bottom: 12px;
            min-height: 180px;
            scroll-behavior: smooth;
        }
        .transcript-placeholder {
            text-align: center;
            color: var(--color-text-light);
            padding: 40px 20px;
        }
        .transcript-text {
            font-size: 22px;
            line-height: 1.6;
            color: var(--color-text);
        }
        .transcript-text .current {
            color: var(--color-green);
            font-weight: 600;
            background: rgba(22, 163, 74, 0.08);
            border-radius: 4px;
            padding: 0 2px;
        }
        
        /* ===== Paused Overlay ===== */
        .paused-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 248, 240, 0.97);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            padding: var(--spacing);
            text-align: center;
            color: var(--color-text);
        }
        .paused-overlay.hidden { display: none; }
        
        .not-recording-badge {
            font-size: 36px;
            font-weight: 800;
            color: var(--color-red);
            margin-bottom: 12px;
            letter-spacing: 1px;
        }
        .paused-overlay h2 {
            font-size: 28px;
            color: var(--color-primary);
            margin-bottom: 12px;
        }
        .paused-overlay p {
            font-size: 20px;
            margin-bottom: 8px;
            color: var(--color-text-light);
        }
        .paused-overlay .reassurance {
            font-size: 20px;
            margin: 20px 0;
            padding: 16px 24px;
            background: rgba(45, 80, 22, 0.08);
            border-radius: var(--radius);
            color: var(--color-primary);
        }
        .paused-overlay .saved-time { font-weight: 700; }
        
        .resume-btn {
            width: 100%;
            max-width: 320px;
            min-height: 80px;
            background: var(--color-green);
            color: var(--color-white);
            border: none;
            border-radius: var(--radius);
            font-size: 26px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 24px;
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.3);
            transition: transform 0.2s;
        }
        .resume-btn:hover { transform: scale(1.03); }
        
        /* ===== Recording Button Area ===== */
        .record-button-area {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            padding: 16px var(--spacing) 28px;
            background: linear-gradient(transparent, var(--color-background) 20%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            gap: 10px;
        }
        
        .record-btn {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            border: none;
            font-size: 44px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s;
            box-shadow: 0 4px 24px rgba(0,0,0,0.15);
        }
        .record-btn.ready {
            background: var(--color-blue);
            color: var(--color-white);
        }
        .record-btn.ready:hover { transform: scale(1.06); }
        .record-btn.recording {
            background: var(--color-green);
            color: var(--color-white);
        }
        .record-btn.recording:hover { transform: scale(1.06); }
        
        .break-btn {
            background: transparent;
            border: 2px solid var(--color-text-light);
            color: var(--color-text-light);
            border-radius: 30px;
            padding: 10px 28px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            display: none;
        }
        .break-btn.visible { display: block; }
        
        /* ===== Stats Footer ===== */
        .stats {
            text-align: center;
            padding: 8px;
            font-size: 15px;
            color: var(--color-text-light);
        }
        
        :focus { outline: 3px solid var(--color-primary); outline-offset: 2px; }
        
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after { animation: none !important; transition: none !important; }
        }
    </style>
</head>
<body>
    
    <!-- Paused Overlay -->
    <div id="paused-overlay" class="paused-overlay hidden">
        <div class="not-recording-badge">‚è∏ NOT RECORDING</div>
        <h2>Taking a Break ‚Äî Your story is safe, don't worry!</h2>
        <div class="reassurance">
            <div id="saving-overlay-status">‚úÖ Saving your words...</div>
            <div style="margin-top:8px;">Saved up to: <span id="saved-time" class="saved-time">0:00</span></div>
        </div>
        <p>Take your time. There's no rush at all. üíõ</p>
        <button id="resume-btn" class="resume-btn">
            ‚ñ∂Ô∏è Resume When Ready
        </button>
    </div>
    
    <!-- Main Container -->
    <div class="container">
        <!-- Header -->
        <div class="header">
            <a href="/" class="logo">üåø InstaBio</a>
            <div class="nav-links">
                <a href="/vault" class="nav-link">Vault</a>
                <a href="/biography" class="nav-link">Bio</a>
            </div>
        </div>
        
        <!-- Interview Mode Toggle -->
        <div class="mode-toggle">
            <button id="mode-free" class="mode-btn active" onclick="setMode('free')">üéôÔ∏è Free Talk</button>
            <button id="mode-guided" class="mode-btn" onclick="setMode('guided')">ü§ñ Guided Interview</button>
        </div>
        <div id="guided-coming-soon" class="guided-coming-soon">
            <h3>ü§ñ Coming Soon!</h3>
            <p>An AI interviewer will ask you questions about your life to help tell your story. Stay tuned!</p>
        </div>
        
        <!-- Wi-Fi Indicator -->
        <div id="wifi-indicator" class="wifi-indicator">üì∂ Checking connection...</div>
        
        <!-- Status Bar -->
        <div class="status-bar">
            <div id="timer" class="timer">0:00</div>
            <div id="status-text" class="status-text">Tap the big blue button whenever you're ready, dear</div>
            <div id="saving-status" class="saving-status"></div>
        </div>
        
        <!-- Transcript Area -->
        <div id="transcript-area" class="transcript-area">
            <div id="transcript-placeholder" class="transcript-placeholder">
                <p style="font-size:40px;">üéôÔ∏è</p>
                <p>Your words will appear here as you speak.</p>
                <p style="font-size: 16px; margin-top: 16px;">Just talk about your life ‚Äî any memory, any story.</p>
            </div>
            <div id="transcript-text" class="transcript-text"></div>
        </div>
        
        <!-- Stats -->
        <div id="stats" class="stats">
            Total recorded: <span id="total-time">0:00</span> ‚Ä¢ 
            <span id="chunk-count">0</span> segments saved
        </div>
    </div>
    
    <!-- Record Button -->
    <div class="record-button-area">
        <button id="break-btn" class="break-btn" onclick="pauseRecording()">‚òï Take a Break</button>
        <button id="record-btn" class="record-btn ready" aria-label="Start recording">
            üéôÔ∏è
        </button>
    </div>
    
    <script>
        // ===== InstaBio Recording Engine =====
        const API_URL = '/api';
        const CHUNK_DURATION_MS = 30000;
        const MAX_TRANSCRIPT_LINES = 500;
        
        // State
        let isRecording = false;
        let isPaused = false;
        let mediaRecorder = null;
        let audioStream = null;
        let sessionUUID = null;
        let sessionId = null;
        let chunkIndex = 0;
        let chunkInterval = null;
        let recordingStartTime = null;
        let pausedTime = 0;
        let timerInterval = null;
        let recognition = null;
        let uploadQueue = [];
        let currentChunks = [];
        let transcriptLines = [];
        
        // DOM Elements
        const pausedOverlay = document.getElementById('paused-overlay');
        const recordBtn = document.getElementById('record-btn');
        const breakBtn = document.getElementById('break-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const timerDisplay = document.getElementById('timer');
        const statusText = document.getElementById('status-text');
        const savingStatus = document.getElementById('saving-status');
        const savingOverlayStatus = document.getElementById('saving-overlay-status');
        const transcriptArea = document.getElementById('transcript-area');
        const transcriptPlaceholder = document.getElementById('transcript-placeholder');
        const transcriptText = document.getElementById('transcript-text');
        const savedTimeSpan = document.getElementById('saved-time');
        const totalTimeSpan = document.getElementById('total-time');
        const chunkCountSpan = document.getElementById('chunk-count');
        const wifiIndicator = document.getElementById('wifi-indicator');
        
        // Auth
        const token = localStorage.getItem('instabio_token');
        if (!token) { window.location.href = '/onboard'; }
        
        // ===== Interview Mode =====
        function setMode(mode) {
            document.getElementById('mode-free').classList.toggle('active', mode === 'free');
            document.getElementById('mode-guided').classList.toggle('active', mode === 'guided');
            document.getElementById('guided-coming-soon').style.display = mode === 'guided' ? 'block' : 'none';
        }
        
        // ===== Wi-Fi Indicator =====
        function updateWifiIndicator() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (conn) {
                const dominated = conn.downlink < 1 || conn.effectiveType === '2g' || conn.effectiveType === 'slow-2g';
                if (dominated) {
                    wifiIndicator.textContent = "üì± Saving to your phone ‚Äî we'll upload when you have better Wi-Fi";
                } else {
                    wifiIndicator.textContent = "üì∂ Strong connection ‚Äî saving as you speak";
                }
            } else {
                wifiIndicator.textContent = navigator.onLine
                    ? "üì∂ Strong connection ‚Äî saving as you speak"
                    : "üì± Saving to your phone ‚Äî we'll upload when you have better Wi-Fi";
            }
        }
        updateWifiIndicator();
        if (navigator.connection) navigator.connection.addEventListener('change', updateWifiIndicator);
        window.addEventListener('online', updateWifiIndicator);
        window.addEventListener('offline', updateWifiIndicator);
        
        // ===== IndexedDB =====
        let db = null;
        
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('InstaBioDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => { db = request.result; resolve(db); };
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains('chunks')) {
                        database.createObjectStore('chunks', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!database.objectStoreNames.contains('queue')) {
                        database.createObjectStore('queue', { keyPath: 'id', autoIncrement: true });
                    }
                };
            });
        }
        
        async function saveChunkLocally(blob, sessionUUID, chunkIndex, duration) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('chunks', 'readwrite');
                const store = tx.objectStore('chunks');
                const chunk = { sessionUUID, chunkIndex, duration, blob, timestamp: Date.now(), uploaded: false };
                const request = store.add(chunk);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function queueForUpload(chunkId) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('queue', 'readwrite');
                const store = tx.objectStore('queue');
                const request = store.add({ chunkId, timestamp: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // ===== Recording Functions =====
        
        function createRecorder() {
            const rec = new MediaRecorder(audioStream, { mimeType: 'audio/webm;codecs=opus' });
            rec.ondataavailable = (e) => {
                if (e.data.size > 0) currentChunks.push(e.data);
            };
            rec.onstop = async () => {
                if (currentChunks.length > 0) await saveCurrentChunk();
                if (isRecording && !isPaused) {
                    currentChunks = [];
                    mediaRecorder = createRecorder();
                    mediaRecorder.start();
                }
            };
            return rec;
        }
        
        async function startRecording() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                });
                
                const response = await fetch(`${API_URL}/session/start`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.detail || 'Failed to start session');
                
                sessionUUID = data.session_uuid;
                sessionId = data.session_id;
                chunkIndex = 0;
                currentChunks = [];
                
                mediaRecorder = createRecorder();
                mediaRecorder.start();
                
                chunkInterval = setInterval(() => {
                    if (isRecording && !isPaused && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, CHUNK_DURATION_MS);
                
                isRecording = true;
                isPaused = false;
                recordingStartTime = Date.now();
                pausedTime = 0;
                
                updateUI('recording');
                startTimer();
                startSpeechRecognition();
                
            } catch (err) {
                console.error('Failed to start recording:', err);
                alert('Could not access microphone. Please allow microphone access and try again.');
            }
        }
        
        async function saveCurrentChunk() {
            if (currentChunks.length === 0) return;
            const blob = new Blob(currentChunks, { type: 'audio/webm' });
            currentChunks = [];
            const duration = CHUNK_DURATION_MS / 1000;
            
            try {
                const chunkId = await saveChunkLocally(blob, sessionUUID, chunkIndex, duration);
                await queueForUpload(chunkId);
                chunkIndex++;
                chunkCountSpan.textContent = chunkIndex;
                uploadChunk(blob, chunkIndex - 1, duration);
            } catch (err) {
                console.error('Failed to save chunk locally:', err);
            }
        }
        
        async function uploadChunk(blob, index, duration) {
            const formData = new FormData();
            formData.append('audio', blob, `chunk_${index}.webm`);
            formData.append('session_uuid', sessionUUID);
            formData.append('chunk_index', index);
            formData.append('duration', duration);
            
            try {
                const response = await fetch(`${API_URL}/upload`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` },
                    body: formData
                });
                if (!response.ok) {
                    uploadQueue.push({ blob, index, duration });
                }
            } catch (err) {
                uploadQueue.push({ blob, index, duration });
            }
        }
        
        function pauseRecording() {
            if (!isRecording || isPaused) return;
            isPaused = true;
            pausedTime += Date.now() - recordingStartTime;
            
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            if (chunkInterval) { clearInterval(chunkInterval); chunkInterval = null; }
            
            stopSpeechRecognition();
            updateUI('paused');
            
            // Show saving status
            savingOverlayStatus.textContent = '‚úÖ Saving your words...';
            setTimeout(() => {
                const mins = Math.floor(pausedTime / 60000);
                savingOverlayStatus.textContent = `‚úÖ All saved! ${mins} minute${mins !== 1 ? 's' : ''} of your story recorded so far`;
            }, 2000);
        }
        
        function resumeRecording() {
            if (!isRecording || !isPaused) return;
            isPaused = false;
            recordingStartTime = Date.now();
            
            currentChunks = [];
            mediaRecorder = createRecorder();
            mediaRecorder.start();
            
            chunkInterval = setInterval(() => {
                if (isRecording && !isPaused && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, CHUNK_DURATION_MS);
            
            updateUI('recording');
            startSpeechRecognition();
        }
        
        async function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            isPaused = false;
            
            if (chunkInterval) { clearInterval(chunkInterval); chunkInterval = null; }
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            if (audioStream) audioStream.getTracks().forEach(track => track.stop());
            
            stopTimer();
            stopSpeechRecognition();
            updateUI('ready');
        }
        
        // ===== Timer =====
        function startTimer() { timerInterval = setInterval(updateTimer, 100); }
        function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }
        
        function updateTimer() {
            if (isPaused) return;
            const elapsed = pausedTime + (Date.now() - recordingStartTime);
            timerDisplay.textContent = formatTime(elapsed);
            savedTimeSpan.textContent = formatTime(elapsed);
        }
        
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // ===== Speech Recognition =====
        function startSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) return;
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = navigator.language || 'en-US';
            
            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                transcriptPlaceholder.style.display = 'none';
                
                if (finalTranscript) {
                    transcriptLines.push(finalTranscript);
                    // Buffer management: keep last ~500 lines
                    if (transcriptLines.length > MAX_TRANSCRIPT_LINES) {
                        transcriptLines = transcriptLines.slice(-Math.floor(MAX_TRANSCRIPT_LINES * 0.8));
                    }
                }
                
                // Rebuild display
                let html = transcriptLines.join('');
                if (interimTranscript) {
                    html += `<span class="current">${interimTranscript}</span>`;
                }
                transcriptText.innerHTML = html;
                
                // Auto-scroll to bottom
                transcriptArea.scrollTop = transcriptArea.scrollHeight;
            };
            
            recognition.onerror = (event) => {
                if (event.error === 'no-speech' && isRecording && !isPaused) {
                    setTimeout(() => { if (isRecording && !isPaused) recognition.start(); }, 100);
                }
            };
            
            recognition.onend = () => {
                if (isRecording && !isPaused) {
                    setTimeout(() => {
                        if (isRecording && !isPaused && recognition) {
                            try { recognition.start(); } catch (e) {}
                        }
                    }, 100);
                }
            };
            
            try { recognition.start(); } catch (e) {}
        }
        
        function stopSpeechRecognition() {
            if (recognition) { try { recognition.stop(); } catch (e) {} }
        }
        
        // ===== UI Updates =====
        function updateUI(state) {
            switch (state) {
                case 'ready':
                    document.body.classList.remove('recording-glow');
                    pausedOverlay.classList.add('hidden');
                    recordBtn.className = 'record-btn ready';
                    recordBtn.innerHTML = 'üéôÔ∏è';
                    recordBtn.setAttribute('aria-label', 'Start recording');
                    breakBtn.classList.remove('visible');
                    statusText.className = 'status-text';
                    statusText.textContent = 'Tap the big blue button whenever you\'re ready, dear';
                    savingStatus.textContent = '';
                    break;
                    
                case 'recording':
                    document.body.classList.add('recording-glow');
                    pausedOverlay.classList.add('hidden');
                    recordBtn.className = 'record-btn recording';
                    recordBtn.innerHTML = 'üéôÔ∏è';
                    recordBtn.setAttribute('aria-label', 'Recording in progress');
                    breakBtn.classList.add('visible');
                    statusText.className = 'status-text recording';
                    statusText.textContent = "I'm listening... keep talking, you're doing great! ‚ú®";
                    savingStatus.textContent = '';
                    break;
                    
                case 'paused':
                    document.body.classList.remove('recording-glow');
                    pausedOverlay.classList.remove('hidden');
                    breakBtn.classList.remove('visible');
                    statusText.className = 'status-text paused';
                    statusText.textContent = '‚è∏ Taking a Break';
                    break;
            }
        }
        
        // ===== Event Listeners =====
        recordBtn.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
            } else if (isPaused) {
                resumeRecording();
            }
            // While recording, the main button stays as a mic icon; pause is via break button
        });
        
        resumeBtn.addEventListener('click', () => { resumeRecording(); });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isRecording && !isPaused) {
                console.log('App backgrounded - recording continues');
            }
        });
        
        window.addEventListener('beforeunload', (e) => {
            if (isRecording) { e.preventDefault(); e.returnValue = 'You have an active recording. Are you sure you want to leave?'; }
        });
        
        // ===== Initialize =====
        async function init() {
            await initDB();
            try {
                const response = await fetch(`${API_URL}/user/stats`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                if (data.success) {
                    totalTimeSpan.textContent = data.total_duration_formatted || '0:00';
                    chunkCountSpan.textContent = data.total_chunks || 0;
                }
            } catch (err) {}
            processUploadQueue();
        }
        
        async function processUploadQueue() {
            while (uploadQueue.length > 0) {
                const item = uploadQueue.shift();
                await uploadChunk(item.blob, item.index, item.duration);
            }
            setTimeout(processUploadQueue, 30000);
        }
        
        init();
    </script>
</body>
</html>
