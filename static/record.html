<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#2D5016">
    <title>Recording â€” InstaBio</title>
    <link rel="manifest" href="/manifest.json">

    <style>
        :root {
            --color-primary: #2D5016;
            --color-primary-light: #3D6B1E;
            --color-background: #FFF8F0;
            --color-white: #FFFFFF;
            --color-text: #1A1A1A;
            --color-text-light: #4A4A4A;
            --color-blue: #2563EB;
            --color-green: #16A34A;
            --color-red: #DC2626;
            --color-warm-bg: #FFFDF5;
            --font-body: 20px;
            --transcript-size: 28px;
            --touch-min: 64px;
            --spacing: 24px;
            --radius: 16px;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: var(--font-body);
            line-height: 1.5;
            color: var(--color-text);
            background: var(--color-background);
            min-height: 100vh;
            overflow-y: auto;
            transition: box-shadow 0.5s ease;
        }

        body.recording-glow {
            animation: green-breathe 4.5s ease-in-out infinite;
            border: 4px solid rgba(22, 163, 74, 0.3);
        }

        @keyframes green-breathe {

            0%,
            100% {
                background-color: #FFF8F0;
                border-color: rgba(22, 163, 74, 0.15);
                box-shadow: inset 0 0 40px 15px rgba(22, 163, 74, 0.1);
            }

            50% {
                background-color: #F5FFF0;
                border-color: rgba(22, 163, 74, 0.5);
                box-shadow: inset 0 0 80px 30px rgba(22, 163, 74, 0.2);
            }
        }

        /* ===== Mode Selection Screen ===== */
        .mode-selection-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--color-background);
            z-index: 1100;
            display: flex;
            flex-direction: column;
            padding: var(--spacing);
            overflow-y: auto;
        }

        .mode-selection-screen.hidden {
            display: none;
        }

        .mode-selection-screen h2 {
            font-size: 28px;
            color: var(--color-primary);
            text-align: center;
            margin-bottom: 8px;
        }

        .mode-selection-screen .subtitle {
            font-size: 22px;
            color: var(--color-text-light);
            text-align: center;
            margin-bottom: 24px;
        }

        .free-talk-option {
            background: var(--color-white);
            border: 3px solid var(--color-primary);
            border-radius: 20px;
            padding: 24px 28px;
            margin-bottom: 24px;
            cursor: pointer;
            text-align: center;
            min-height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06);
            -webkit-tap-highlight-color: rgba(45, 80, 22, 0.15);
        }

        .free-talk-option:hover,
        .free-talk-option.selected {
            border-color: var(--color-green);
            border-width: 4px;
            background: linear-gradient(135deg, #F0FFF0 0%, #E8F8E8 100%);
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.2), 0 2px 4px rgba(22, 163, 74, 0.1);
        }

        .free-talk-option:active {
            transform: translateY(1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .free-talk-option .icon {
            font-size: 40px;
        }

        .free-talk-option .label {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-text);
        }

        .free-talk-option .desc {
            font-size: 18px;
            color: var(--color-text-light);
        }

        .guided-label {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-primary);
            text-align: center;
            margin: 16px 0 12px;
        }

        .mode-card {
            background: var(--color-white);
            border: 3px solid #D4C9B8;
            border-radius: 20px;
            padding: 24px 28px;
            margin-bottom: 16px;
            cursor: pointer;
            min-height: 110px;
            display: flex;
            align-items: center;
            gap: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06);
            -webkit-tap-highlight-color: rgba(45, 80, 22, 0.15);
        }

        .mode-card:hover {
            border-color: var(--color-primary);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12), 0 3px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        .mode-card:active {
            transform: translateY(1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .mode-card.selected {
            border-color: var(--color-green);
            border-width: 4px;
            background: linear-gradient(135deg, #F0FFF0 0%, #E8F8E8 100%);
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.2), 0 2px 4px rgba(22, 163, 74, 0.1);
        }

        .mode-card .icon {
            font-size: 52px;
            flex-shrink: 0;
            width: 64px;
            text-align: center;
        }

        .mode-card .card-text {
            flex: 1;
            min-width: 0;
        }

        .mode-card .card-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-text);
            line-height: 1.2;
        }

        .mode-card .card-desc {
            font-size: 18px;
            color: var(--color-text-light);
            margin-top: 6px;
            line-height: 1.3;
        }

        .begin-btn {
            width: 100%;
            min-height: 80px;
            background: var(--color-green);
            color: var(--color-white);
            border: none;
            border-radius: var(--radius);
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.3);
            transition: transform 0.2s;
        }

        .begin-btn:hover {
            transform: scale(1.03);
        }

        .begin-btn:disabled {
            background: #ccc;
            box-shadow: none;
            transform: none;
            cursor: default;
        }

        /* ===== Text Size Slider ===== */
        .text-size-slider {
            position: fixed;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            background: rgba(255, 248, 240, 0.85);
            border-radius: 24px;
            padding: 12px 6px;
            backdrop-filter: blur(4px);
        }

        .text-size-slider.visible {
            display: flex;
        }

        .text-size-slider .big-a {
            font-size: 36px;
            font-weight: 800;
            color: var(--color-primary);
        }

        .text-size-slider .small-a {
            font-size: 18px;
            font-weight: 600;
            color: var(--color-text-light);
        }

        .text-size-slider input[type="range"] {
            writing-mode: vertical-lr;
            direction: rtl;
            width: 44px;
            height: 180px;
            appearance: none;
            -webkit-appearance: none;
            background: transparent;
        }

        .text-size-slider input[type="range"]::-webkit-slider-runnable-track {
            width: 8px;
            background: rgba(45, 80, 22, 0.2);
            border-radius: 4px;
        }

        .text-size-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--color-primary);
            cursor: pointer;
            border: 3px solid var(--color-white);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            margin-left: -18px;
        }

        .text-size-slider input[type="range"]::-moz-range-thumb {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--color-primary);
            cursor: pointer;
            border: 3px solid var(--color-white);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .text-size-slider input[type="range"]::-moz-range-track {
            width: 8px;
            background: rgba(45, 80, 22, 0.2);
            border-radius: 4px;
        }

        /* ===== Interview Panel ===== */
        .interview-panel {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .interview-panel.visible {
            display: flex;
        }

        .avatar-area {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            overflow: hidden;
            border: 4px solid var(--color-primary);
            background: #e8e0d4;
            flex-shrink: 0;
        }

        .avatar-area img,
        .avatar-area video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .avatar-area.speaking {
            animation: avatar-pulse 2s ease-in-out infinite;
        }

        @keyframes avatar-pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(45, 80, 22, 0.4);
            }

            50% {
                box-shadow: 0 0 0 16px rgba(45, 80, 22, 0);
            }
        }

        .question-display {
            background: #FEFCF3;
            border-radius: var(--radius);
            padding: 16px 20px;
            font-size: var(--transcript-size);
            line-height: 1.5;
            color: var(--color-text);
            border-left: 6px solid var(--color-primary);
            width: 100%;
            text-align: left;
        }

        .question-display .q-icon {
            font-size: 28px;
            margin-right: 8px;
        }

        .interview-thinking {
            display: none;
            color: var(--color-primary);
            font-size: 22px;
            font-weight: 600;
            text-align: center;
            padding: 16px;
        }

        .interview-thinking.visible {
            display: block;
            animation: thinking-fade 2s ease-in-out infinite;
        }

        @keyframes thinking-fade {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        /* ===== Main Container ===== */
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 12px var(--spacing) 100px;
            padding-right: 70px;
            /* room for text slider */
        }

        /* ===== Header ===== */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: var(--color-primary);
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 8px;
        }

        .nav-link {
            font-size: 20px;
            color: var(--color-primary);
            text-decoration: underline;
            padding: 12px;
            min-height: 48px;
            display: flex;
            align-items: center;
        }

        /* ===== Wi-Fi Indicator ===== */
        .wifi-indicator {
            text-align: center;
            font-size: 16px;
            padding: 4px 12px;
            border-radius: 8px;
            margin-bottom: 4px;
            background: rgba(45, 80, 22, 0.08);
            color: var(--color-text-light);
            flex-shrink: 0;
        }

        /* ===== Status Bar ===== */
        .status-bar {
            text-align: center;
            padding: 8px 16px;
            background: var(--color-white);
            border-radius: var(--radius);
            margin-bottom: 6px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }

        .timer {
            font-size: 40px;
            font-weight: 700;
            color: var(--color-primary);
            font-variant-numeric: tabular-nums;
            line-height: 1.1;
        }

        .status-text {
            font-size: 20px;
            color: var(--color-text-light);
        }

        .status-text.recording {
            color: var(--color-green);
            font-weight: 600;
        }

        .status-text.paused {
            color: var(--color-red);
        }

        .saving-status {
            font-size: 16px;
            color: var(--color-primary);
            min-height: 20px;
        }

        /* ===== Transcript Area ===== */
        .transcript-area {
            flex: 1;
            background: var(--color-white);
            border-radius: var(--radius);
            padding: 16px;
            overflow-y: scroll;
            margin-bottom: 4px;
            min-height: 200px;
            max-height: 50vh;
            scroll-behavior: smooth;
            display: flex;
            flex-direction: column;
        }

        .transcript-placeholder {
            text-align: center;
            color: var(--color-text-light);
            padding: 40px 20px;
            align-self: center;
        }

        .transcript-placeholder p {
            font-size: 22px;
        }

        .transcript-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .transcript-line {
            font-size: var(--transcript-size);
            line-height: 1.6;
            color: var(--color-text);
        }

        .transcript-line .current {
            color: var(--color-green);
            font-weight: 700;
            background: rgba(22, 163, 74, 0.08);
            border-radius: 4px;
            padding: 0 2px;
        }

        .transcript-line.question-line {
            background: #FEFCF3;
            border-left: 5px solid var(--color-primary);
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px 0;
            font-style: italic;
            color: var(--color-primary-light);
        }

        /* ===== Paused Overlay ===== */
        .paused-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #FFF8F0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            padding: var(--spacing);
            text-align: center;
            color: var(--color-text);
        }

        .paused-overlay.hidden {
            display: none;
        }

        .not-recording-badge {
            font-size: 36px;
            font-weight: 800;
            color: var(--color-red);
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .paused-overlay h2 {
            font-size: 28px;
            color: var(--color-primary);
            margin-bottom: 12px;
        }

        .paused-overlay p {
            font-size: 22px;
            margin-bottom: 8px;
            color: var(--color-text-light);
        }

        .paused-overlay .reassurance {
            font-size: 22px;
            margin: 20px 0;
            padding: 16px 24px;
            background: rgba(45, 80, 22, 0.08);
            border-radius: var(--radius);
            color: var(--color-primary);
        }

        .paused-overlay .saved-time {
            font-weight: 700;
        }

        .resume-btn {
            width: 100%;
            max-width: 320px;
            min-height: 80px;
            background: var(--color-green);
            color: var(--color-white);
            border: none;
            border-radius: var(--radius);
            font-size: 26px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 24px;
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.3);
            transition: transform 0.2s;
        }

        .resume-btn:hover {
            transform: scale(1.03);
        }

        /* ===== Recording Button Area â€” Minimal Floating ===== */
        .record-button-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 12px var(--spacing) 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 100;
            pointer-events: none;
        }

        .record-button-area>* {
            pointer-events: auto;
        }

        .record-btn {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            font-size: 48px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .record-btn.ready {
            background: var(--color-green);
            color: var(--color-white);
        }

        .record-btn.ready:hover {
            transform: scale(1.06);
        }

        .record-btn.recording {
            background: var(--color-green);
            color: var(--color-white);
            animation: btn-strobe 3s ease-in-out infinite;
        }

        .record-btn.recording:hover {
            transform: scale(1.06);
        }

        @keyframes btn-strobe {

            0%,
            100% {
                box-shadow: 0 0 12px 4px rgba(22, 163, 74, 0.3);
                opacity: 1;
            }

            50% {
                box-shadow: 0 0 30px 12px rgba(22, 163, 74, 0.6);
                opacity: 0.85;
            }
        }

        .break-btn {
            background: rgba(255, 248, 240, 0.85);
            border: 2px solid var(--color-text-light);
            color: var(--color-text-light);
            border-radius: 30px;
            padding: 10px 20px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            display: none;
            min-height: 52px;
            backdrop-filter: blur(4px);
        }

        .break-btn.visible {
            display: block;
        }

        /* ===== Stats Footer ===== */
        .stats {
            text-align: center;
            padding: 4px;
            font-size: 16px;
            color: var(--color-text-light);
            flex-shrink: 0;
        }

        /* ===== Encouragements ===== */
        .encouragement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: 700;
            color: var(--color-primary);
            background: rgba(255, 248, 240, 0.95);
            padding: 16px 32px;
            border-radius: var(--radius);
            z-index: 300;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }

        .encouragement.show {
            opacity: 1;
        }

        :focus {
            outline: 3px solid var(--color-primary);
            outline-offset: 2px;
        }

        @media (prefers-reduced-motion: reduce) {

            *,
            *::before,
            *::after {
                animation: none !important;
                transition: none !important;
            }
        }

        /* ===== R1.1 RED Interrupted State ===== */
        body.interrupted-state {
            border: 8px solid #CC3333 !important;
            animation: flash-red 0.8s ease-in-out infinite alternate !important;
        }

        @keyframes flash-red {
            from {
                border-color: #CC3333;
                box-shadow: inset 0 0 30px rgba(204, 51, 51, 0.08);
            }

            to {
                border-color: #881111;
                box-shadow: inset 0 0 60px rgba(204, 51, 51, 0.15);
            }
        }

        .interrupted-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #FFF0F0 0%, #FFF8F0 40%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: var(--spacing);
            text-align: center;
        }

        .interrupted-overlay.hidden {
            display: none;
        }

        .interrupted-badge {
            font-size: 32px;
            font-weight: 800;
            color: #CC3333;
            margin-bottom: 8px;
        }

        .interrupted-overlay h2 {
            font-size: 26px;
            color: var(--color-primary);
            margin-bottom: 12px;
        }

        .interrupted-overlay .safe-msg {
            font-size: 22px;
            padding: 16px 24px;
            margin: 12px 0;
            background: rgba(45, 80, 22, 0.08);
            border-radius: var(--radius);
            color: var(--color-primary);
        }

        .interrupted-overlay .last-saved-info {
            font-size: 20px;
            color: var(--color-text-light);
            margin: 8px 0;
        }

        .interrupted-overlay .last-saved-info strong {
            color: var(--color-primary);
        }

        .auto-resume-countdown {
            font-size: 36px;
            font-weight: 800;
            color: var(--color-green);
            margin: 16px 0 4px;
            min-height: 48px;
        }

        .auto-resume-label {
            font-size: 18px;
            color: var(--color-text-light);
            margin-bottom: 16px;
        }

        .interrupted-buttons {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .interrupted-buttons button {
            min-height: 64px;
            padding: 0 32px;
            border-radius: var(--radius);
            font-size: 22px;
            font-weight: 700;
            cursor: pointer;
            border: none;
        }

        .btn-resume-now {
            background: var(--color-green);
            color: #fff;
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.3);
        }

        .btn-stay-paused {
            background: var(--color-white);
            color: var(--color-text);
            border: 2px solid #ccc !important;
        }

        /* ===== R1.3 Heartbeat Dot ===== */
        .heartbeat-dot {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 500;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--color-green);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .heartbeat-dot.active {
            opacity: 1;
            animation: hb-pulse 1.5s ease-in-out infinite;
        }

        .heartbeat-dot.error {
            background: #CC3333;
        }

        @keyframes hb-pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.8;
            }

            50% {
                transform: scale(1.4);
                opacity: 1;
            }
        }

        /* ===== R1.4 Silence Toast ===== */
        .silence-toast {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 248, 240, 0.97);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius);
            padding: 16px 24px;
            z-index: 600;
            font-size: 20px;
            color: var(--color-text);
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            max-width: 90%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s;
        }

        .silence-toast.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .silence-toast button {
            margin-top: 12px;
            padding: 10px 24px;
            border-radius: 8px;
            border: none;
            background: var(--color-primary);
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
        }

        /* ===== R1.8 Crash Recovery Banner ===== */
        .crash-recovery {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #F0FFF0 0%, #E8F8E8 100%);
            border-bottom: 3px solid var(--color-primary);
            padding: 16px 24px;
            z-index: 1200;
            text-align: center;
        }

        .crash-recovery.hidden {
            display: none;
        }

        .crash-recovery h3 {
            font-size: 22px;
            color: var(--color-primary);
            margin-bottom: 8px;
        }

        .crash-recovery p {
            font-size: 18px;
            color: var(--color-text-light);
            margin-bottom: 12px;
        }

        .crash-recovery .cr-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .crash-recovery .cr-buttons button {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            min-height: 48px;
        }

        .cr-continue {
            background: var(--color-green);
            color: #fff;
        }

        .cr-fresh {
            background: var(--color-white);
            color: var(--color-text);
            border: 2px solid #ccc !important;
        }

        /* ===== R1.9 Upload Progress Bar ===== */
        .upload-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(45, 80, 22, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 4px;
        }

        .upload-progress-bar .fill {
            height: 100%;
            width: 0%;
            background: var(--color-green);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        .cloud-status {
            font-size: 16px;
            color: var(--color-primary);
            min-height: 22px;
        }

        /* === MOBILE RESPONSIVE === */
        @media (max-width: 600px) {
            .container {
                padding: 8px;
            }

            .status-bar {
                flex-direction: column;
                gap: 4px;
                padding: 8px;
            }

            .timer {
                font-size: 28px;
            }

            .status-text {
                font-size: 14px;
            }

            .record-btn {
                width: 100px;
                height: 100px;
                font-size: 40px;
            }

            .transcript-area {
                padding: 12px;
                min-height: 200px;
            }

            .transcript-area h3 {
                font-size: 16px;
            }

            h1,
            h2 {
                font-size: 20px;
            }

            .wifi-indicator {
                font-size: 13px !important;
                padding: 6px;
            }

            .encouragement {
                font-size: 16px;
                padding: 12px 16px;
            }

            .session-stats {
                font-size: 13px;
                gap: 8px;
            }
        }
    </style>
</head>

<body>
    <script src="/static/i18n.js"></script>
    <script src="/static/shared.js"></script>
    <script>renderNav('record');</script>

    <!-- R1.3 Heartbeat Dot -->
    <div id="heartbeat-dot" class="heartbeat-dot"></div>

    <!-- R1.1/R1.6 Interrupted Overlay (RED state + auto-resume) -->
    <div id="interrupted-overlay" class="interrupted-overlay hidden">
        <div class="interrupted-badge">âš ï¸ RECORDING PAUSED</div>
        <h2>Don't worry â€” everything is safe!</h2>
        <div class="safe-msg" id="interrupted-safe-msg">
            âœ… Your recording was paused automatically. All your words are saved.
        </div>
        <div class="last-saved-info">
            Last saved: <strong id="interrupted-last-saved">just now</strong> Â· <strong
                id="interrupted-chunks">0</strong> chunks safe
        </div>
        <div id="auto-resume-countdown" class="auto-resume-countdown"></div>
        <div id="auto-resume-label" class="auto-resume-label"></div>
        <div class="interrupted-buttons">
            <button class="btn-resume-now" onclick="resumeFromInterruption()">â–¶ï¸ Resume Now</button>
            <button class="btn-stay-paused" onclick="stayPaused()">â˜• Stay Paused</button>
        </div>
    </div>

    <!-- R1.4 Silence Toast -->
    <div id="silence-toast" class="silence-toast">
        <div id="silence-toast-msg">Are you still there? Your recording is running. ğŸ™ï¸</div>
        <button onclick="dismissSilenceToast()">I'm here! Keep recording</button>
    </div>

    <!-- R1.8 Crash Recovery Banner -->
    <div id="crash-recovery" class="crash-recovery hidden">
        <h3>ğŸŒ¿ Welcome back!</h3>
        <p id="crash-recovery-msg">We saved everything from your last session.</p>
        <div class="cr-buttons">
            <button class="cr-continue" onclick="continueRecovery()">Continue Recording</button>
            <button class="cr-fresh" onclick="dismissRecovery()">Start Fresh</button>
        </div>
    </div>

    <!-- Mode Selection Screen -->
    <div id="mode-selection" class="mode-selection-screen hidden">
        <h2>ğŸŒ¿ How would you like to tell your story?</h2>
        <p class="subtitle">Pick whichever feels most comfortable</p>

        <div class="free-talk-option" id="opt-free" onclick="selectMode('free')">
            <span class="icon">ğŸ’¬</span>
            <div>
                <div class="label">Just Talk Freely</div>
                <div class="desc">No questions â€” just share whatever comes to mind</div>
            </div>
        </div>

        <div class="guided-label">â€” or let someone guide you â€”</div>

        <div class="mode-card" id="opt-face" onclick="selectMode('face')">
            <span class="icon">ğŸ‘©â€ğŸ’¼</span>
            <div class="card-text">
                <div class="card-title">Face to Face</div>
                <div class="card-desc">See and hear your interviewer</div>
            </div>
        </div>

        <div class="mode-card" id="opt-fireside" onclick="selectMode('fireside')">
            <span class="icon">ğŸ™ï¸</span>
            <div class="card-text">
                <div class="card-title">Fireside Chat</div>
                <div class="card-desc">Just listen and talk</div>
            </div>
        </div>

        <div class="mode-card" id="opt-quiet" onclick="selectMode('quiet')">
            <span class="icon">ğŸ“</span>
            <div class="card-text">
                <div class="card-title">Quiet Mode</div>
                <div class="card-desc">Read questions silently â€” perfect for noisy places</div>
            </div>
        </div>

        <div class="guided-label">â€” or record yourself on video â€”</div>

        <div class="mode-card" id="opt-video" onclick="selectMode('video')" style="border-color:#9333ea;">
            <span class="icon">ğŸ“¹</span>
            <div class="card-text">
                <div class="card-title">Video Story</div>
                <div class="card-desc">Record video of yourself telling your story</div>
            </div>
        </div>

        <div
            style="margin:16px 0; padding:16px; background:linear-gradient(135deg, #f0fdf4, #ecfdf5); border-radius:12px; border:1px solid #bbf7d0; font-size:14px; line-height:1.6;">
            <div style="font-weight:600; font-size:15px; margin-bottom:8px;">âœ¨ Your recordings do triple duty:</div>
            <div style="display:grid; gap:8px;">
                <div>ğŸ“– <strong>Your Story</strong> â€” Every word becomes part of your biography & lifetime journal</div>
                <div>ğŸ¤ <strong>Voice Clone</strong> â€” Your audio recordings train an AI to speak in your voice, so your
                    story can be read aloud to future generations <em>in your own voice</em></div>
                <div>ğŸ‘¤ <strong>Avatar Clone</strong> â€” Video recordings capture your expressions, mannerisms, and
                    appearance to create a lifelike digital avatar that can tell your stories face-to-face</div>
            </div>
            <div style="margin-top:10px; font-size:13px; color:#666;">ğŸ’¡ The more you record, the more accurate and
                lifelike your voice and avatar become. Even 10 minutes of video is enough to get started!</div>
        </div>

        <button id="begin-btn" class="begin-btn" disabled onclick="beginRecording()">ğŸŒŸ Let's Begin!</button>
    </div>

    <!-- Paused Overlay -->
    <div id="paused-overlay" class="paused-overlay hidden">
        <div class="not-recording-badge">â¸ NOT RECORDING</div>
        <h2>Taking a Break â€” Your story is safe!</h2>
        <div class="reassurance">
            <div id="saving-overlay-status">âœ… Saving your words...</div>
            <div style="margin-top:8px;">Saved up to: <span id="saved-time" class="saved-time">0:00</span></div>
        </div>
        <p>Take your time. There's no rush at all. ğŸ’›</p>
        <button id="resume-btn" class="resume-btn">
            â–¶ï¸ Continue When Ready
        </button>
    </div>

    <!-- Text Size Slider -->
    <div id="text-size-slider" class="text-size-slider">
        <span class="big-a">A</span>
        <input type="range" id="size-slider" min="18" max="52" value="28" oninput="changeTextSize(this.value)">
        <span class="small-a">a</span>
    </div>

    <!-- Encouragement popup -->
    <div id="encouragement" class="encouragement"></div>

    <!-- Main Container -->
    <div class="container">
        <!-- Header controlled by shared nav -->

        <!-- Wi-Fi Indicator -->
        <div id="wifi-indicator" class="wifi-indicator">ğŸ“¶ Checking connection...</div>
        <div id="transcription-badge" class="wifi-indicator" style="font-size:14px;">ğŸ”„ Checking transcription...</div>
        <div id="language-badge" class="wifi-indicator" style="font-size:14px; display:none;"></div>
        <div id="sticky-language-bar"
            style="position:sticky; top:0; z-index:100; background:rgba(255,255,255,0.95); backdrop-filter:blur(8px); padding:8px 16px; border-bottom:1px solid #e5e7eb; display:flex; align-items:center; justify-content:center; gap:8px; font-size:14px; color:#555;">
            ğŸŒ Language:
            <select id="language-select" onchange="changeRecognitionLanguage(this.value)"
                style="padding:8px 12px; border-radius:8px; border:2px solid var(--color-primary); font-size:15px; min-height:44px; background:#fff; cursor:pointer; font-weight:500; color:var(--color-text);">
                <optgroup label="Americas & Europe">
                    <option value="en-US">ğŸ‡ºğŸ‡¸ English</option>
                    <option value="es-ES">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                    <option value="fr-FR">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                    <option value="pt-BR">ğŸ‡§ğŸ‡· PortuguÃªs</option>
                    <option value="de-DE">ğŸ‡©ğŸ‡ª Deutsch</option>
                    <option value="it-IT">ğŸ‡®ğŸ‡¹ Italiano</option>
                    <option value="nl-NL">ğŸ‡³ğŸ‡± Nederlands</option>
                    <option value="pl-PL">ğŸ‡µğŸ‡± Polski</option>
                    <option value="ro-RO">ğŸ‡·ğŸ‡´ RomÃ¢nÄƒ</option>
                    <option value="sv-SE">ğŸ‡¸ğŸ‡ª Svenska</option>
                    <option value="hu-HU">ğŸ‡­ğŸ‡º Magyar</option>
                    <option value="uk-UA">ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°</option>
                    <option value="el-GR">ğŸ‡¬ğŸ‡· Î•Î»Î»Î·Î½Î¹ÎºÎ¬</option>
                    <option value="ru-RU">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                    <option value="tr-TR">ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e</option>
                </optgroup>
                <optgroup label="Asia & Pacific">
                    <option value="zh-CN">ğŸ‡¨ğŸ‡³ ä¸­æ–‡ (ç®€ä½“)</option>
                    <option value="zh-TW">ğŸ‡¹ğŸ‡¼ ä¸­æ–‡ (ç¹é«”)</option>
                    <option value="ja-JP">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
                    <option value="ko-KR">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
                    <option value="hi-IN">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
                    <option value="bn-IN">ğŸ‡®ğŸ‡³ à¦¬à¦¾à¦‚à¦²à¦¾</option>
                    <option value="ta-IN">ğŸ‡®ğŸ‡³ à®¤à®®à®¿à®´à¯</option>
                    <option value="ur-PK">ğŸ‡µğŸ‡° Ø§Ø±Ø¯Ùˆ</option>
                    <option value="th-TH">ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢</option>
                    <option value="vi-VN">ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t</option>
                    <option value="id-ID">ğŸ‡®ğŸ‡© Bahasa Indonesia</option>
                    <option value="ms-MY">ğŸ‡²ğŸ‡¾ Bahasa Melayu</option>
                    <option value="fil-PH">ğŸ‡µğŸ‡­ Filipino</option>
                </optgroup>
                <optgroup label="Middle East & Africa">
                    <option value="ar-SA">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                    <option value="fa-IR">ğŸ‡®ğŸ‡· ÙØ§Ø±Ø³ÛŒ</option>
                    <option value="he-IL">ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª</option>
                    <option value="sw-KE">ğŸ‡°ğŸ‡ª Kiswahili</option>
                </optgroup>
            </select>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div id="timer" class="timer">0:00</div>
            <div id="status-text" class="status-text">Tap the big green button whenever you're ready, dear</div>
            <div id="saving-status" class="saving-status"></div>
            <div class="upload-progress-bar">
                <div id="upload-fill" class="fill"></div>
            </div>
            <div id="cloud-status" class="cloud-status"></div>
        </div>

        <!-- Interview Panel (shown during recording in guided modes) -->
        <div id="interview-panel" class="interview-panel">
            <div id="avatar-area" class="avatar-area" style="display:none;">
                <video id="avatar-video" style="display:none;" playsinline></video>
                <img id="avatar-portrait" src="/static/portraits/default.jpg" alt="Interviewer"
                    onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><circle cx=%2250%22 cy=%2235%22 r=%2220%22 fill=%22%232D5016%22/><ellipse cx=%2250%22 cy=%2280%22 rx=%2230%22 ry=%2220%22 fill=%22%232D5016%22/></svg>'">
            </div>
            <div id="question-display" class="question-display" style="display:none;"></div>
            <div id="interview-thinking" class="interview-thinking">ğŸ’­ Thinking of your next question...</div>
            <button id="next-question-btn" onclick="requestNextQuestion()"
                style="display:none; margin:8px auto; padding:12px 24px; font-size:16px; border-radius:25px; border:2px solid var(--color-primary); background:white; color:var(--color-primary); cursor:pointer; font-weight:600;">
                â¡ï¸ Next Question
            </button>
        </div>

        <!-- Video Preview (shown during Video Story mode) -->
        <video id="video-preview" autoplay muted playsinline
            style="display:none; width:160px; height:120px; border-radius:12px; border:3px solid var(--color-primary); position:fixed; bottom:100px; right:16px; z-index:999; object-fit:cover; box-shadow:0 4px 12px rgba(0,0,0,0.2); background:#000;"></video>

        <!-- Transcript Area -->
        <div id="transcript-area" class="transcript-area">
            <div id="transcript-placeholder" class="transcript-placeholder">
                <p style="font-size:48px;">ğŸ™ï¸</p>
                <p>Your words will appear here as you speak.</p>
                <p style="margin-top: 16px;">Just talk about your life â€” any memory, any story.</p>
            </div>
            <div id="transcript-content" class="transcript-content"></div>
        </div>

        <!-- Stats -->
        <div id="stats" class="stats">
            Total recorded: <span id="total-time">0:00</span> â€¢
            <span id="chunk-count">0</span> parts saved
        </div>

        <!-- Storage Info -->
        <div id="storage-info"
            style="text-align:center; padding:8px 16px; font-size:13px; color:#666; background:rgba(255,255,255,0.7); border-radius:8px; margin:4px 0; display:flex; align-items:center; justify-content:center; gap:8px; flex-wrap:wrap;">
            <span>ğŸ’¾ Your words are stored:</span>
            <select id="storage-select" onchange="changeStorageLocation(this.value)"
                style="padding:4px 8px; border-radius:6px; border:1px solid #ccc; font-size:13px; background:#fff; cursor:pointer;">
                <option value="local" selected>ğŸ“± On This Device</option>
                <option value="server">ğŸ–¥ï¸ InstaBio Server</option>
                <option value="gdrive">ğŸ“ Google Drive</option>
                <option value="dropbox">ğŸ“¦ Dropbox</option>
            </select>
            <span id="storage-status" style="color:var(--color-primary);">âœ… Secure</span>
        </div>
    </div>

    <!-- Record Button â€” Floating bottom corners -->
    <div class="record-button-area">
        <button id="break-btn" class="break-btn" onclick="pauseRecording()">â˜• Break</button>
        <button id="record-btn" class="record-btn ready" aria-label="Start recording">
            ğŸ™ï¸
        </button>
        <button id="mode-btn" class="break-btn" onclick="showModeSelection()"
            style="background:var(--color-primary-light); font-size:14px; padding:10px 16px;">
            ğŸ”„ Change Mode
        </button>
    </div>

    <script>
        // ===== InstaBio Recording Engine =====
        const API_URL = '/api';
        const CHUNK_DURATION_MS = 30000;
        const MAX_TRANSCRIPT_LINES = 500;

        // State
        let isRecording = false;
        let isPaused = false;
        let mediaRecorder = null;
        let audioStream = null;
        let sessionUUID = null;
        let sessionId = null;
        let chunkIndex = 0;
        let chunkInterval = null;
        let recordingStartTime = null;
        let pausedTime = 0;
        let timerInterval = null;
        let recognition = null;
        let uploadQueue = [];
        let currentChunks = [];
        let transcriptLines = [];

        // Auth (must be before any code that uses userKey)
        const token = localStorage.getItem('instabio_token');
        const _uid = token ? token.substring(0, 8) : 'anon';
        function userKey(key) { return `${key}_${_uid}`; }

        // Restore transcript from localStorage if returning to page
        (function restoreTranscript() {
            try {
                const saved = localStorage.getItem(userKey('instabio_transcript'));
                if (saved) {
                    const lines = JSON.parse(saved);
                    if (Array.isArray(lines) && lines.length > 0) {
                        transcriptLines = lines;
                        const tc = document.getElementById('transcript-content');
                        const tp = document.getElementById('transcript-placeholder');
                        if (tp) tp.style.display = 'none';
                        lines.forEach(line => {
                            const div = document.createElement('div');
                            div.className = 'transcript-line';
                            div.style.fontSize = 'var(--transcript-size)';
                            div.textContent = line;
                            tc.appendChild(div);
                        });
                    }
                }
            } catch (e) { }
        })();

        // Interview state
        let selectedMode = localStorage.getItem(userKey('instabio_mode')) || null;
        let interviewMode = false;
        let videoMode = false;
        let interviewSubMode = null; // 'face', 'fireside', 'quiet'
        let interviewSessionId = null;
        let interviewSilenceTimer = null;
        let lastSpeechTime = Date.now();
        let currentInterviewTranscript = '';

        // Text size
        let textSize = parseInt(localStorage.getItem(userKey('instabio_textsize'))) || 28;

        // Encouragements
        const encouragements = [
            "You're doing wonderful! âœ¨",
            "What a great story! ğŸ’›",
            "Keep going, this is beautiful! ğŸŒ¿",
            "Your family will treasure this! ğŸ’š",
            "That's so interesting! ğŸ˜Š",
        ];
        let lastEncouragementTime = 0;

        // DOM Elements
        const pausedOverlay = document.getElementById('paused-overlay');
        const recordBtn = document.getElementById('record-btn');
        const breakBtn = document.getElementById('break-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const timerDisplay = document.getElementById('timer');
        const statusText = document.getElementById('status-text');
        const savingStatus = document.getElementById('saving-status');
        const savingOverlayStatus = document.getElementById('saving-overlay-status');
        const transcriptArea = document.getElementById('transcript-area');
        const transcriptPlaceholder = document.getElementById('transcript-placeholder');
        const transcriptContent = document.getElementById('transcript-content');
        const savedTimeSpan = document.getElementById('saved-time');
        const totalTimeSpan = document.getElementById('total-time');
        const chunkCountSpan = document.getElementById('chunk-count');
        const wifiIndicator = document.getElementById('wifi-indicator');
        const modeSelection = document.getElementById('mode-selection');
        const textSizeSlider = document.getElementById('text-size-slider');
        const sizeSliderInput = document.getElementById('size-slider');
        const beginBtnEl = document.getElementById('begin-btn');

        // Auth â€” defined above (before restoreTranscript IIFE)

        // ===== Mode Selection =====
        function selectMode(mode) {
            selectedMode = mode;

            // Clear all selections
            document.querySelectorAll('.mode-card, .free-talk-option').forEach(el => el.classList.remove('selected'));

            // Highlight selected
            const map = { free: 'opt-free', face: 'opt-face', fireside: 'opt-fireside', quiet: 'opt-quiet', video: 'opt-video' };
            document.getElementById(map[mode]).classList.add('selected');

            beginBtnEl.disabled = false;
            localStorage.setItem(userKey('instabio_mode'), mode);
        }

        function showModeSelection() {
            // Pause recording if active before switching modes
            if (isRecording && !isPaused) {
                pauseRecording();
            }
            modeSelection.classList.remove('hidden');
            if (selectedMode) selectMode(selectedMode);
        }

        function beginRecording() {
            if (!selectedMode) return;
            modeSelection.classList.add('hidden');

            if (selectedMode === 'free') {
                interviewMode = false;
                interviewSubMode = null;
                videoMode = false;
            } else if (selectedMode === 'video') {
                interviewMode = false;
                interviewSubMode = null;
                videoMode = true;
            } else {
                interviewMode = true;
                interviewSubMode = selectedMode; // 'face', 'fireside', 'quiet'
                videoMode = false;
            }

            startRecording();
        }

        // ===== Text Size =====
        function changeTextSize(val) {
            textSize = parseInt(val);
            document.documentElement.style.setProperty('--transcript-size', textSize + 'px');
            localStorage.setItem(userKey('instabio_textsize'), textSize);
        }
        // Initialize text size
        sizeSliderInput.value = textSize;
        changeTextSize(textSize);

        // ===== Interview Functions =====
        async function startInterview() {
            try {
                const selectedLang = document.getElementById('language-select')?.value || 'en-US';
                const resp = await fetch(`${API_URL}/interview/start`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ portrait_id: 'default', language: selectedLang })
                });
                const data = await resp.json();
                if (data.success) {
                    interviewSessionId = data.session_id;
                    showInterviewQuestion(data.question, data.video_url, data.portrait);
                }
            } catch (e) {
                console.error('Failed to start interview:', e);
                showInterviewQuestion("Hello! Let's start at the very beginning â€” where and when were you born?", null, null);
                interviewSessionId = 'fallback-' + Date.now();
            }
        }

        function showInterviewQuestion(question, videoUrl, portrait) {
            const questionDisplay = document.getElementById('question-display');
            const avatarArea = document.getElementById('avatar-area');
            const avatarVideo = document.getElementById('avatar-video');
            const avatarImg = document.getElementById('avatar-portrait');
            const thinking = document.getElementById('interview-thinking');

            thinking.classList.remove('visible');

            // Add question to transcript as a special line
            addQuestionToTranscript(question);

            // Configure based on sub-mode
            if (interviewSubMode === 'face') {
                avatarArea.style.display = 'block';
                questionDisplay.style.display = 'block';
                questionDisplay.innerHTML = `<span class="q-icon">ğŸ‘©â€ğŸ’¼</span> ${escapeHtml(question)}`;

                if (videoUrl) {
                    avatarVideo.src = videoUrl;
                    avatarVideo.style.display = 'block';
                    avatarImg.style.display = 'none';
                    avatarVideo.play().catch(() => { });
                    avatarArea.classList.add('speaking');
                    avatarVideo.onended = () => avatarArea.classList.remove('speaking');
                } else {
                    avatarVideo.style.display = 'none';
                    avatarImg.style.display = 'block';
                    if (portrait && portrait.image_url) avatarImg.src = portrait.image_url;
                    avatarArea.classList.add('speaking');
                    speakQuestion(question, () => avatarArea.classList.remove('speaking'));
                }
            } else if (interviewSubMode === 'fireside') {
                avatarArea.style.display = 'none';
                questionDisplay.style.display = 'block';
                questionDisplay.innerHTML = `<span class="q-icon">ğŸ™ï¸</span> ${escapeHtml(question)}`;
                speakQuestion(question);
            } else if (interviewSubMode === 'quiet') {
                avatarArea.style.display = 'none';
                questionDisplay.style.display = 'block';
                questionDisplay.innerHTML = `<span class="q-icon">ğŸ“</span> ${escapeHtml(question)}`;
                // No voice in quiet mode
            }

            currentInterviewTranscript = '';
            lastSpeechTime = Date.now();
            startSilenceDetection();

            // Show "Next Question" button for manual advancement
            const nextBtn = document.getElementById('next-question-btn');
            if (nextBtn) nextBtn.style.display = 'block';
        }

        function speakQuestion(text, onEnd) {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.85;
                utterance.pitch = 1.05;
                if (onEnd) utterance.onend = onEnd;
                speechSynthesis.speak(utterance);
            } else if (onEnd) {
                setTimeout(onEnd, 3000);
            }
        }

        function addQuestionToTranscript(question) {
            const div = document.createElement('div');
            div.className = 'transcript-line question-line';
            div.style.fontSize = 'var(--transcript-size)';
            div.textContent = question;
            transcriptContent.appendChild(div);
            transcriptArea.scrollTop = transcriptArea.scrollHeight;
        }

        function startSilenceDetection() {
            if (interviewSilenceTimer) clearInterval(interviewSilenceTimer);
            interviewSilenceTimer = setInterval(() => {
                if (!interviewMode || !isRecording || isPaused) return;
                const silenceSec = (Date.now() - lastSpeechTime) / 1000;
                // Only auto-advance after 15s of silence AND if user actually spoke
                if (currentInterviewTranscript.trim().length > 10 && silenceSec >= 15) {
                    requestNextQuestion();
                }
            }, 1000);
        }

        const askedQuestions = new Set();
        const fallbackQuestions = [
            "Tell me about a happy memory from your childhood.",
            "What's a lesson you learned the hard way?",
            "Who had the biggest influence on your life?",
            "What are you most proud of?",
            "Tell me about a time you overcame something difficult.",
            "What do you want future generations to know about you?",
            "Describe a place that feels like home to you.",
            "What's the best advice you've ever received?",
        ];
        let fallbackIndex = 0;

        async function requestNextQuestion() {
            if (interviewSilenceTimer) clearInterval(interviewSilenceTimer);

            const thinking = document.getElementById('interview-thinking');
            const nextBtn = document.getElementById('next-question-btn');
            thinking.classList.add('visible');
            if (nextBtn) nextBtn.style.display = 'none'; // Hide while fetching

            try {
                const selectedLang = document.getElementById('language-select')?.value || 'en-US';
                const resp = await fetch(`${API_URL}/interview/next`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: interviewSessionId,
                        transcript: currentInterviewTranscript,
                        portrait_id: 'default',
                        language: selectedLang
                    })
                });
                const data = await resp.json();
                if (data.success) {
                    // Prevent repeating the exact same question
                    if (askedQuestions.has(data.question)) {
                        const fb = fallbackQuestions[fallbackIndex % fallbackQuestions.length];
                        fallbackIndex++;
                        showInterviewQuestion(fb, null, null);
                    } else {
                        askedQuestions.add(data.question);
                        showInterviewQuestion(data.question, data.video_url, null);
                    }
                }
            } catch (e) {
                console.error('Failed to get next question:', e);
                thinking.classList.remove('visible');
                const fb = fallbackQuestions[fallbackIndex % fallbackQuestions.length];
                fallbackIndex++;
                showInterviewQuestion(fb, null, null);
            }
        }

        // ===== Wi-Fi Indicator =====
        function updateWifiIndicator() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (conn) {
                const slow = conn.downlink < 1 || conn.effectiveType === '2g' || conn.effectiveType === 'slow-2g';
                wifiIndicator.textContent = slow
                    ? "ğŸ“± Saving to your phone â€” we'll send it when Wi-Fi is better"
                    : "ğŸ“¶ Good connection â€” saving as you speak";
            } else {
                wifiIndicator.textContent = navigator.onLine
                    ? "ğŸ“¶ Good connection â€” saving as you speak"
                    : "ğŸ“± Saving to your phone â€” we'll send it when Wi-Fi is better";
            }
        }
        updateWifiIndicator();
        if (navigator.connection) navigator.connection.addEventListener('change', updateWifiIndicator);
        window.addEventListener('online', updateWifiIndicator);
        window.addEventListener('offline', updateWifiIndicator);

        // ===== IndexedDB =====
        let db = null;

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('InstaBioDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => { db = request.result; resolve(db); };
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains('chunks')) {
                        database.createObjectStore('chunks', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!database.objectStoreNames.contains('queue')) {
                        database.createObjectStore('queue', { keyPath: 'id', autoIncrement: true });
                    }
                };
            });
        }

        async function saveChunkLocally(blob, sessionUUID, chunkIndex, duration) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('chunks', 'readwrite');
                const store = tx.objectStore('chunks');
                const chunk = { sessionUUID, chunkIndex, duration, blob, timestamp: Date.now(), uploaded: false };
                const request = store.add(chunk);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function queueForUpload(chunkId) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction('queue', 'readwrite');
                const store = tx.objectStore('queue');
                const request = store.add({ chunkId, timestamp: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // ===== Recording Functions =====
        function createRecorder() {
            const mimeType = videoMode ? 'video/webm;codecs=vp9,opus' : 'audio/webm;codecs=opus';
            const rec = new MediaRecorder(audioStream, { mimeType });
            rec.ondataavailable = (e) => {
                if (e.data.size > 0) currentChunks.push(e.data);
            };
            rec.onstop = async () => {
                if (currentChunks.length > 0) await saveCurrentChunk();
                if (isRecording && !isPaused) {
                    currentChunks = [];
                    mediaRecorder = createRecorder();
                    mediaRecorder.start();
                }
            };
            return rec;
        }

        async function startRecording() {
            try {
                const constraints = videoMode
                    ? { video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }, audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } }
                    : { audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } };
                audioStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Show video preview if in video mode
                const videoPreview = document.getElementById('video-preview');
                if (videoMode && videoPreview) {
                    videoPreview.srcObject = audioStream;
                    videoPreview.style.display = 'block';
                } else if (videoPreview) {
                    videoPreview.style.display = 'none';
                }

                const response = await fetch(`${API_URL}/session/start`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.detail || 'Failed to start');

                sessionUUID = data.session_uuid;
                sessionId = data.session_id;
                chunkIndex = 0;
                currentChunks = [];

                mediaRecorder = createRecorder();
                mediaRecorder.start();

                chunkInterval = setInterval(() => {
                    if (isRecording && !isPaused && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, CHUNK_DURATION_MS);

                isRecording = true;
                isPaused = false;
                recordingStartTime = Date.now();
                pausedTime = 0;

                updateUI('recording');
                startTimer();
                startSpeechRecognition();
                startHeartbeat();
                startTripleConfirmation();

                // R2.1: Start WebSocket streaming transcription
                startStreamingTranscription();

                // Show text size slider
                textSizeSlider.classList.add('visible');

                // Show interview panel if guided mode
                if (interviewMode) {
                    document.getElementById('interview-panel').classList.add('visible');
                    if (!interviewSessionId) startInterview();
                }

            } catch (err) {
                console.error('Failed to start recording:', err);
                statusText.textContent = "Could not access microphone. Please allow microphone access and try again.";
                statusText.style.color = 'var(--color-red)';
            }
        }

        async function saveCurrentChunk() {
            if (currentChunks.length === 0) return;
            const blob = new Blob(currentChunks, { type: 'audio/webm' });
            currentChunks = [];
            const duration = CHUNK_DURATION_MS / 1000;

            try {
                const chunkId = await saveChunkLocally(blob, sessionUUID, chunkIndex, duration);
                await queueForUpload(chunkId);
                chunkIndex++;
                chunkCountSpan.textContent = chunkIndex;
                uploadChunk(blob, chunkIndex - 1, duration);
            } catch (err) {
                console.error('Failed to save chunk locally:', err);
            }
        }

        const UPLOAD_MAX_RETRIES = 3;
        const UPLOAD_BASE_DELAY_MS = 2000; // 2s, 4s, 8s

        async function uploadChunk(blob, index, duration, attempt = 0) {
            const formData = new FormData();
            formData.append('audio', blob, `chunk_${index}.webm`);
            formData.append('session_uuid', sessionUUID);
            formData.append('chunk_index', index);
            formData.append('duration', duration);

            updateCloudStatus(true);
            try {
                const response = await fetch(`${API_URL}/upload`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` },
                    body: formData
                });
                if (response.ok) {
                    if (attempt > 0) savingStatus.textContent = 'âœ… Chunk saved successfully!';
                    lastSavedTimestamp = Date.now();
                    updateCloudStatus(false);
                    saveRecoveryState();
                    return true; // success
                }
                throw new Error(`Server returned ${response.status}`);
            } catch (err) {
                if (attempt < UPLOAD_MAX_RETRIES) {
                    const delay = UPLOAD_BASE_DELAY_MS * Math.pow(2, attempt);
                    savingStatus.textContent = `ğŸ“¡ Trying to saveâ€¦ attempt ${attempt + 2} of ${UPLOAD_MAX_RETRIES + 1}`;
                    console.warn(`Chunk ${index} upload failed (attempt ${attempt + 1}), retrying in ${delay}msâ€¦`, err.message);
                    await new Promise(r => setTimeout(r, delay));
                    return uploadChunk(blob, index, duration, attempt + 1);
                }
                // All retries exhausted â€” save to offline queue
                console.error(`Chunk ${index} upload failed after ${UPLOAD_MAX_RETRIES + 1} attempts. Saving offline.`);
                savingStatus.textContent = 'ğŸ“± Saved to your phone â€” will send when connection is better';
                uploadQueue.push({ blob, index, duration, retries: 0 });
                return false;
            }
        }

        function pauseRecording() {
            if (!isRecording || isPaused) return;
            isPaused = true;
            pausedTime += Date.now() - recordingStartTime;

            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            if (chunkInterval) { clearInterval(chunkInterval); chunkInterval = null; }

            stopSpeechRecognition();
            if ('speechSynthesis' in window) speechSynthesis.cancel();
            updateUI('paused');

            savingOverlayStatus.textContent = 'âœ… Saving your words...';
            setTimeout(() => {
                const mins = Math.floor(pausedTime / 60000);
                savingOverlayStatus.textContent = `âœ… All saved! ${mins} minute${mins !== 1 ? 's' : ''} of your story recorded so far`;
            }, 2000);
        }

        function resumeRecording() {
            if (!isRecording || !isPaused) return;
            isPaused = false;
            recordingStartTime = Date.now();

            currentChunks = [];
            mediaRecorder = createRecorder();
            mediaRecorder.start();

            chunkInterval = setInterval(() => {
                if (isRecording && !isPaused && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, CHUNK_DURATION_MS);

            updateUI('recording');
            startSpeechRecognition();
        }

        async function stopRecording() {
            if (!isRecording) return;
            isRecording = false;
            isPaused = false;
            isInterrupted = false;

            if (chunkInterval) { clearInterval(chunkInterval); chunkInterval = null; }
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            if (audioStream) audioStream.getTracks().forEach(track => track.stop());

            stopTimer();
            stopSpeechRecognition();
            stopHeartbeat();
            stopTripleConfirmation();
            stopStreamingTranscription();
            dismissSilenceToast();
            document.body.classList.remove('interrupted-state');
            interruptedOverlay.classList.add('hidden');
            localStorage.removeItem(userKey('instabio_recovery'));
            if ('speechSynthesis' in window) speechSynthesis.cancel();
            updateUI('ready');
            textSizeSlider.classList.remove('visible');

            // Hide video preview
            const videoPreview = document.getElementById('video-preview');
            if (videoPreview) { videoPreview.style.display = 'none'; videoPreview.srcObject = null; }

            if (interviewSilenceTimer) { clearInterval(interviewSilenceTimer); interviewSilenceTimer = null; }
            interviewSessionId = null;
            document.getElementById('interview-panel').classList.remove('visible');
        }

        // ===== Timer =====
        function startTimer() { timerInterval = setInterval(updateTimer, 100); }
        function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }

        function updateTimer() {
            if (isPaused) return;
            const elapsed = pausedTime + (Date.now() - recordingStartTime);
            timerDisplay.textContent = formatTime(elapsed);
            savedTimeSpan.textContent = formatTime(elapsed);

            // Occasional encouragement
            const now = Date.now();
            if (now - lastEncouragementTime > 120000 && elapsed > 60000) {
                lastEncouragementTime = now;
                showEncouragement();
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            if (hours > 0) return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function showEncouragement() {
            const el = document.getElementById('encouragement');
            el.textContent = encouragements[Math.floor(Math.random() * encouragements.length)];
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 3000);
        }

        // ===== Speech Recognition =====
        let currentLang = document.getElementById('language-select')?.value || navigator.language || 'en-US';

        function changeRecognitionLanguage(lang) {
            currentLang = lang;
            // Update the "Detected" badge to show chosen language
            const langBadge = document.getElementById('language-badge');
            const langCode = lang.split('-')[0].toUpperCase();
            langBadge.style.display = 'block';
            langBadge.textContent = `ğŸŒ Active: ${langCode}`;
            if (recognition && isRecording && !isPaused) {
                // Restart recognition with new language
                stopSpeechRecognition();
                setTimeout(() => startSpeechRecognition(), 200);
            }
        }

        function changeStorageLocation(location) {
            localStorage.setItem(userKey('instabio_storage'), location);
            const statusEl = document.getElementById('storage-status');
            const labels = {
                'local': 'âœ… Secure â€” saved on this device',
                'server': 'â˜ï¸ Syncing to InstaBio servers',
                'gdrive': 'ğŸ“ Google Drive (coming soon)',
                'dropbox': 'ğŸ“¦ Dropbox (coming soon)'
            };
            statusEl.textContent = labels[location] || 'âœ… Secure';
            if (location === 'gdrive' || location === 'dropbox') {
                statusEl.textContent += ' â€” connect in Settings';
            }
        }
        // Restore saved storage preference
        (function () {
            const saved = localStorage.getItem(userKey('instabio_storage'));
            if (saved) {
                const sel = document.getElementById('storage-select');
                if (sel) { sel.value = saved; changeStorageLocation(saved); }
            }
        })();

        function startSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) return;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = currentLang;

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                        if (interviewMode) lastSpeechTime = Date.now();
                    }
                }

                transcriptPlaceholder.style.display = 'none';

                // Auto-scroll to transcript on first speech (mobile: text appears below fold)
                if (!window._hasScrolledToTranscript) {
                    window._hasScrolledToTranscript = true;
                    try { transcriptArea.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) { }
                }

                if (finalTranscript) {
                    transcriptLines.push(finalTranscript);
                    // Auto-save transcript to localStorage for persistence
                    try { localStorage.setItem(userKey('instabio_transcript'), JSON.stringify(transcriptLines)); } catch (e) { }
                    if (interviewMode) {
                        currentInterviewTranscript += finalTranscript;
                        lastSpeechTime = Date.now();
                    }
                    if (transcriptLines.length > MAX_TRANSCRIPT_LINES) {
                        transcriptLines = transcriptLines.slice(-Math.floor(MAX_TRANSCRIPT_LINES * 0.8));
                    }

                    // Add final text as a new line element
                    const div = document.createElement('div');
                    div.className = 'transcript-line';
                    div.style.fontSize = 'var(--transcript-size)';
                    div.textContent = finalTranscript;
                    transcriptContent.appendChild(div);
                }

                // Update or create interim element
                let interimEl = document.getElementById('interim-text');
                if (interimTranscript) {
                    if (!interimEl) {
                        interimEl = document.createElement('div');
                        interimEl.id = 'interim-text';
                        interimEl.className = 'transcript-line';
                        interimEl.style.fontSize = 'var(--transcript-size)';
                        transcriptContent.appendChild(interimEl);
                    }
                    interimEl.innerHTML = `<span class="current">${escapeHtml(interimTranscript)}</span>`;
                } else if (interimEl) {
                    interimEl.remove();
                }

                // Auto-scroll always
                transcriptArea.scrollTop = transcriptArea.scrollHeight;
            };

            recognition.onerror = (event) => {
                if (event.error === 'no-speech' && isRecording && !isPaused) {
                    setTimeout(() => { if (isRecording && !isPaused) recognition.start(); }, 100);
                }
            };

            recognition.onend = () => {
                if (isRecording && !isPaused) {
                    setTimeout(() => {
                        if (isRecording && !isPaused && recognition) {
                            try { recognition.start(); } catch (e) { }
                        }
                    }, 100);
                }
            };

            try { recognition.start(); } catch (e) { }
        }

        function stopSpeechRecognition() {
            if (recognition) { try { recognition.stop(); } catch (e) { } }
        }

        // ===== UI Updates =====
        function updateUI(state) {
            switch (state) {
                case 'ready':
                    document.body.classList.remove('recording-glow');
                    pausedOverlay.classList.add('hidden');
                    recordBtn.className = 'record-btn ready';
                    recordBtn.innerHTML = 'ğŸ™ï¸';
                    recordBtn.setAttribute('aria-label', 'Start recording');
                    breakBtn.classList.remove('visible');
                    statusText.className = 'status-text';
                    statusText.textContent = 'Tap the big green button whenever you\'re ready, dear';
                    savingStatus.textContent = '';
                    break;

                case 'recording':
                    document.body.classList.add('recording-glow');
                    pausedOverlay.classList.add('hidden');
                    recordBtn.className = 'record-btn recording';
                    recordBtn.innerHTML = 'ğŸ™ï¸';
                    recordBtn.setAttribute('aria-label', 'Recording â€” you\'re doing great!');
                    breakBtn.classList.add('visible');
                    statusText.className = 'status-text recording';
                    statusText.textContent = "I'm listening... keep talking, you're doing great! âœ¨";
                    savingStatus.textContent = '';
                    break;

                case 'paused':
                    document.body.classList.remove('recording-glow');
                    pausedOverlay.classList.remove('hidden');
                    breakBtn.classList.remove('visible');
                    statusText.className = 'status-text paused';
                    statusText.textContent = 'â¸ Taking a Break';
                    break;
            }
        }

        // ===== R1 â€” Recording UX Hardening =====
        // R1.1/R1.2/R1.6 â€” Interrupted State + Auto-Resume
        let lastSavedTimestamp = null;
        let autoResumeTimer = null;
        let autoResumeCount = 0;
        let isInterrupted = false;
        const interruptedOverlay = document.getElementById('interrupted-overlay');
        const heartbeatDot = document.getElementById('heartbeat-dot');
        const silenceToast = document.getElementById('silence-toast');
        const silenceToastMsg = document.getElementById('silence-toast-msg');
        const cloudStatusEl = document.getElementById('cloud-status');
        const uploadFill = document.getElementById('upload-fill');

        function triggerRedState(reason) {
            if (!isRecording || isPaused || isInterrupted) return;
            isInterrupted = true;
            document.body.classList.add('interrupted-state');
            document.body.classList.remove('recording-glow');
            // Pause recording mechanics
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            if (chunkInterval) { clearInterval(chunkInterval); chunkInterval = null; }
            stopSpeechRecognition();
            stopHeartbeat();
            // Update interrupted overlay info
            document.getElementById('interrupted-last-saved').textContent =
                lastSavedTimestamp ? new Date(lastSavedTimestamp).toLocaleTimeString() : 'just now';
            document.getElementById('interrupted-chunks').textContent = chunkIndex;
            interruptedOverlay.classList.remove('hidden');
            // Start auto-resume countdown (5 seconds)
            startAutoResumeCountdown();
        }

        function startAutoResumeCountdown() {
            autoResumeCount = 5;
            const countdownEl = document.getElementById('auto-resume-countdown');
            const labelEl = document.getElementById('auto-resume-label');
            labelEl.textContent = 'Resuming automatically...';
            countdownEl.textContent = autoResumeCount;
            autoResumeTimer = setInterval(() => {
                autoResumeCount--;
                if (autoResumeCount <= 0) {
                    clearInterval(autoResumeTimer);
                    autoResumeTimer = null;
                    resumeFromInterruption();
                } else {
                    countdownEl.textContent = autoResumeCount;
                }
            }, 1000);
        }

        function resumeFromInterruption() {
            if (autoResumeTimer) { clearInterval(autoResumeTimer); autoResumeTimer = null; }
            isInterrupted = false;
            document.body.classList.remove('interrupted-state');
            interruptedOverlay.classList.add('hidden');
            document.getElementById('auto-resume-countdown').textContent = '';
            document.getElementById('auto-resume-label').textContent = '';
            // Resume recording
            currentChunks = [];
            mediaRecorder = createRecorder();
            mediaRecorder.start();
            chunkInterval = setInterval(() => {
                if (isRecording && !isPaused && mediaRecorder.state === 'recording') mediaRecorder.stop();
            }, CHUNK_DURATION_MS);
            document.body.classList.add('recording-glow');
            startSpeechRecognition();
            startHeartbeat();
        }

        function stayPaused() {
            if (autoResumeTimer) { clearInterval(autoResumeTimer); autoResumeTimer = null; }
            document.getElementById('auto-resume-countdown').textContent = '';
            document.getElementById('auto-resume-label').textContent = 'Take your time. Tap Resume when ready. ğŸ’š';
            isInterrupted = false;
            isPaused = true;
            pausedTime += Date.now() - recordingStartTime;
            document.body.classList.remove('interrupted-state');
            interruptedOverlay.classList.add('hidden');
            updateUI('paused');
        }

        // R1.3 â€” Heartbeat Monitor
        let heartbeatInterval = null;
        let silenceCounter = 0;
        let recorderFailCount = 0; // Tolerance counter for MediaRecorder state checks
        let analyser = null;

        function startHeartbeat() {
            if (!audioStream) return;
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(audioStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
            } catch (e) { /* analyser optional */ }

            heartbeatDot.classList.add('active');
            heartbeatDot.classList.remove('error');
            silenceCounter = 0;

            heartbeatInterval = setInterval(() => {
                if (!isRecording || isPaused || isInterrupted) return;
                // Check MediaRecorder state â€” with tolerance to avoid false red screens
                if (mediaRecorder && mediaRecorder.state !== 'recording') {
                    recorderFailCount++;
                    // Only trigger red state after 3 consecutive failures (~9s)
                    // This prevents false alarms during chunk rotation or TTS playback
                    if (recorderFailCount >= 3 && !interviewMode) {
                        heartbeatDot.classList.add('error');
                        triggerRedState('Recording stopped unexpectedly');
                        return;
                    }
                } else {
                    recorderFailCount = 0; // Reset on success
                }
                // Check audio level
                if (analyser) {
                    const dataArray = new Uint8Array(analyser.fftSize);
                    analyser.getByteTimeDomainData(dataArray);
                    let maxAmp = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        const v = Math.abs(dataArray[i] - 128);
                        if (v > maxAmp) maxAmp = v;
                    }
                    if (maxAmp < 2) {
                        silenceCounter++;
                    } else {
                        silenceCounter = 0;
                        dismissSilenceToast();
                    }
                }
                // R1.4 â€” Silence detection (non-interview mode)
                if (!interviewMode && silenceCounter >= 10) { // 30s
                    showSilenceToast(false);
                }
                if (!interviewMode && silenceCounter >= 40) { // 2 min
                    showSilenceToast(true);
                }
            }, 3000);
        }

        function stopHeartbeat() {
            if (heartbeatInterval) { clearInterval(heartbeatInterval); heartbeatInterval = null; }
            heartbeatDot.classList.remove('active', 'error');
        }

        // R1.4 â€” Silence Toast
        function showSilenceToast(persistent) {
            if (persistent) {
                silenceToastMsg.textContent = "We haven't heard anything for 2 minutes. Would you like to pause?";
            } else {
                silenceToastMsg.textContent = "Are you still there? Your recording is running. ğŸ™ï¸";
            }
            silenceToast.classList.add('visible');
            if (!persistent) setTimeout(() => silenceToast.classList.remove('visible'), 10000);
        }

        function dismissSilenceToast() {
            silenceToast.classList.remove('visible');
            silenceCounter = 0;
        }

        // R1.5 â€” Triple Confirmation (optional audio tick + haptic)
        let tripleConfirmInterval = null;
        function startTripleConfirmation() {
            let elapsed = 0;
            tripleConfirmInterval = setInterval(() => {
                elapsed += 60;
                // Haptic every 5 min on mobile
                if (elapsed % 300 === 0 && navigator.vibrate) {
                    navigator.vibrate(100);
                }
            }, 60000);
        }
        function stopTripleConfirmation() {
            if (tripleConfirmInterval) { clearInterval(tripleConfirmInterval); tripleConfirmInterval = null; }
        }

        // R1.8 â€” Crash Recovery
        function saveRecoveryState() {
            // Always save transcript regardless of session
            if (transcriptLines.length > 0) {
                localStorage.setItem(userKey('instabio_transcript'), JSON.stringify(transcriptLines));
            }
            if (!sessionUUID) return;
            const state = {
                sessionUuid: sessionUUID, sessionId: sessionId,
                chunksSaved: chunkIndex,
                totalDuration: pausedTime + (Date.now() - (recordingStartTime || Date.now())),
                lastSaveTime: new Date().toISOString(), timestamp: Date.now()
            };
            localStorage.setItem(userKey('instabio_recovery'), JSON.stringify(state));
        }

        function checkCrashRecovery() {
            const raw = localStorage.getItem(userKey('instabio_recovery'));
            if (!raw) return;
            try {
                const state = JSON.parse(raw);
                const age = Date.now() - state.timestamp;
                if (age > 24 * 60 * 60 * 1000) { localStorage.removeItem(userKey('instabio_recovery')); return; }
                const mins = Math.floor(state.totalDuration / 60000);
                document.getElementById('crash-recovery-msg').textContent =
                    `We saved ${state.chunksSaved} chunks (${mins} min) from your last session. Ready to continue?`;
                document.getElementById('crash-recovery').classList.remove('hidden');
            } catch (e) { localStorage.removeItem(userKey('instabio_recovery')); }
        }

        function continueRecovery() {
            const raw = localStorage.getItem(userKey('instabio_recovery'));
            if (raw) {
                try {
                    const state = JSON.parse(raw);
                    sessionUUID = state.sessionUuid;
                    sessionId = state.sessionId;
                    chunkIndex = state.chunksSaved;
                    pausedTime = state.totalDuration;
                } catch (e) { }
            }
            localStorage.removeItem(userKey('instabio_recovery'));
            document.getElementById('crash-recovery').classList.add('hidden');
            showModeSelection();
        }

        function dismissRecovery() {
            localStorage.removeItem(userKey('instabio_recovery'));
            document.getElementById('crash-recovery').classList.add('hidden');
        }

        // R1.9 â€” Upload tracking
        let chunksUploaded = 0;
        let chunksTotal = 0;

        function updateCloudStatus(uploading) {
            if (uploading) {
                cloudStatusEl.textContent = 'â˜ï¸â¬†ï¸ Uploading...';
                uploadFill.style.width = '50%';
            } else if (!navigator.onLine) {
                cloudStatusEl.textContent = 'â˜ï¸âŒ Offline â€” saved locally';
                uploadFill.style.width = '0%';
            } else {
                cloudStatusEl.textContent = `â˜ï¸âœ… All synced Â· ${chunkIndex} chunks`;
                uploadFill.style.width = '100%';
                setTimeout(() => { uploadFill.style.width = '0%'; }, 2000);
            }
        }

        // ===== R2: WebSocket Streaming Transcription =====
        let streamWs = null;
        let streamRecorder = null;

        function startStreamingTranscription() {
            try {
                const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                streamWs = new WebSocket(`${wsProtocol}//${location.host}/ws/transcribe`);
                streamWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        // R2.3: Language detection (only if user hasn't manually chosen)
                        if (data.language) {
                            const langBadge = document.getElementById('language-badge');
                            const langSelect = document.getElementById('language-select');
                            // Show server detection only if user is on default (English)
                            // Otherwise, the user's manual selection takes priority
                            if (!langSelect || langSelect.value === 'en-US') {
                                langBadge.style.display = 'block';
                                langBadge.textContent = `ğŸŒ Detected: ${data.language.toUpperCase()}`;
                            }
                        }
                    } catch (e) { /* ignore parse errors */ }
                };
                streamWs.onclose = () => { streamWs = null; };
                streamWs.onerror = () => { streamWs = null; };

                // Send audio chunks over WebSocket for streaming
                if (audioStream) {
                    try {
                        streamRecorder = new MediaRecorder(audioStream, { mimeType: 'audio/webm;codecs=opus' });
                        const streamChunks = [];
                        streamRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0 && streamWs && streamWs.readyState === WebSocket.OPEN) {
                                e.data.arrayBuffer().then(buf => {
                                    if (streamWs && streamWs.readyState === WebSocket.OPEN) {
                                        streamWs.send(buf);
                                    }
                                });
                            }
                        };
                        streamRecorder.start(3000); // 3-second chunks for streaming
                    } catch (e) { /* streaming recorder optional */ }
                }
            } catch (e) {
                console.log('WebSocket streaming not available:', e);
            }
        }

        function stopStreamingTranscription() {
            if (streamRecorder && streamRecorder.state !== 'inactive') {
                try { streamRecorder.stop(); } catch (e) { }
            }
            streamRecorder = null;
            if (streamWs) {
                try { streamWs.close(); } catch (e) { }
                streamWs = null;
            }
        }

        // ===== Event Listeners =====
        recordBtn.addEventListener('click', () => {
            if (!isRecording) {
                showModeSelection();
            } else if (isPaused) {
                resumeRecording();
            }
        });

        resumeBtn.addEventListener('click', () => { resumeRecording(); });

        // R1.1 â€” Visibility change â†’ RED interrupted state
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isRecording && !isPaused && !isInterrupted) {
                // App went to background â€” trigger RED state
                triggerRedState('App was backgrounded');
            } else if (!document.hidden && isInterrupted) {
                // Returned â€” the interrupted overlay is already showing with auto-resume
            }
        });

        window.addEventListener('beforeunload', (e) => {
            // Save transcript and state â€” don't stop recording aggressively
            // Chunks are auto-synced, so just persist for recovery
            saveRecoveryState();
        });

        // ===== Initialize =====
        async function init() {
            await initDB();
            checkCrashRecovery();
            try {
                const response = await fetch(`${API_URL}/user/stats`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                if (data.success) {
                    totalTimeSpan.textContent = data.total_duration_formatted || '0:00';
                    chunkCountSpan.textContent = data.total_chunks || 0;
                }
            } catch (err) { }            // R2.2: Check transcription status (hardware detection)
            try {
                const tsResp = await fetch(`${API_URL}/transcription/status`);
                const tsData = await tsResp.json();
                const tsBadge = document.getElementById('transcription-badge');
                tsBadge.textContent = tsData.message || 'ğŸ“ Transcription after upload';
            } catch (e) {
                document.getElementById('transcription-badge').textContent = 'ğŸ“ Transcription will happen after upload';
            }

            processUploadQueue();
        }

        async function processUploadQueue() {
            if (uploadQueue.length === 0) {
                setTimeout(processUploadQueue, 30000);
                return;
            }
            // Process a snapshot of the queue; don't endlessly re-queue
            const batch = uploadQueue.splice(0, uploadQueue.length);
            for (const item of batch) {
                const success = await uploadChunk(item.blob, item.index, item.duration);
                if (!success) {
                    // uploadChunk already pushed it back with retries exhausted;
                    // don't double-push
                }
            }
            setTimeout(processUploadQueue, 30000);
        }

        // Flush upload queue immediately when network comes back
        window.addEventListener('online', () => {
            savingStatus.textContent = 'ğŸ“¶ Back online â€” sending saved recordingsâ€¦';
            processUploadQueue();
        });

        init();
    </script>
</body>

</html>